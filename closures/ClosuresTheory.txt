{
  /**    
    What is closure --> Closures is a function that remembers variables from its lexical scope even after the outer function has finished executing.
    Problems it solves--> 1. It helps in data privacy by encapsulating variables within a function scope. 2. It heps in data preservations between function calls. 
    How it works Internally --> when a function is created JS attaches a refrence to its outer lexical environment, - Even after the outer function has executed that environment kept alive, - Because the inner function still refrences it, GC cannot clean it
    ğŸ‘‰ This is why closures â€œrememberâ€ values.
    
    âœ… Correct Real-World Closure Example (Bank Account)
    function userAccount() {
        let balance = 500; // private variable

        return {
            debit(amount) {
            if (amount <= balance) {
                balance -= amount;
                return balance;
            } else {
                return "Insufficient balance";
            }
            },

            credit(amount) {
            balance += amount;
            return balance;
            },

            getBalance() {
            return balance;
            }
        };
    }

    const userAcc = userAccount();

    userAcc.credit(200);   // 700
    userAcc.debit(200);    // 500
    userAcc.getBalance();  // 500

    ğŸ§  Memory Leaks & Closures (Interview Favorite) â“ Can closures cause memory leaks?
      
     Yes,If clousers are not managed properly,they can lead to memory leaks by keeping the refrences alive longer than necessary.
    âœ… How to avoid it
    we can avoid it by nullifying refrences when they are no longer needed or by limiting the scope of closures to only what is necessary - or cleanup listners/timers. clearInterval(id);
    element.removeEventListener(...) -Avoid storing unnecessary large data inside closures

â“ Is Every Function a Closure? 
    technically yes, because every function is created with refrences to its lexical environment, Howvever a function is called a clousere only when it accesses variables from an outer scope after that outer function finished executing.
    
1ï¸âƒ£ Closures with Event Listeners (VERY IMPORTANT)

    ğŸ”¹ The core idea
    Event listeners run later, not immediately.
    Closures allow them to remember variables from when they were created. That is why we can access loop variables inside event listeners.
    
    âŒ Common Bug (classic interview trap)
        for (var i = 0; i < 3; i++) {
        button.addEventListener("click", function () {
            console.log(i);
        });
        }

        ğŸ‘‰ Clicking prints: 3 3 3
            Why?
            var is function-scoped
            All listeners close over the same i
            Loop finishes â†’ i = 3

        âœ… Fixed with Closures
        for (let i = 0; i < 3; i++) {
        button.addEventListener("click", function () {
            console.log(i);
        });

        With var â†’ all closures share one variable
        With let â†’ each iteration gets its own variable

4ï¸âƒ£ Memoization Using Closures (Performance Gold)
ğŸ”¹ Problem

Expensive function runs repeatedly with same inputs.

âŒ Without memoization
function slowSquare(n) {
  console.log("Calculating...");
  return n * n;
}

âœ… Memoization with Closure
function memoize(fn) {
  const cache = {};

  return function (n) {
    if (cache[n]) {
      return cache[n];
    }

    cache[n] = fn(n);
    return cache[n];
  };
}

const memoSquare = memoize(slowSquare);

memoSquare(5); // Calculating...
memoSquare(5); // cached

ğŸ§  Why closure is essential here

cache persists between calls

But is not globally accessible

Perfect use-case of closure

    âŒ Buggy Code (VERY COMMON)
    const [count, setCount] = useState(0);

    useEffect(() => {
    setInterval(() => {
        console.log(count);
    }, 1000);
    }, []);


    ğŸ‘‰ Always logs 0

    useEffect(() => {
  const id = setInterval(() => {
    console.log(count);
  }, 1000);

  return () => clearInterval(id);
}, []); // âŒ empty deps

ğŸ”¹ What React does internally
Render #1
count = 0
useEffect runs ONCE

Closure created:
Closure Scope:
  count â†’ 0

â±ï¸ Interval runs every secondâ€¦

ğŸ“Œ Output forever:

0
0
0
0

â— Why this happens (core reason)
Effects capture state at render time

Just like:

var i loop

outer() closure

ğŸ§  Visual Timeline (THIS IS THE KEY)
Render #1
count = 0
â†“
useEffect runs
â†“
setInterval created â†’ remembers count = 0
-----------------------------------
Render #2
count = 1 (new variable)
interval âŒ unchanged
-----------------------------------
Render #3
count = 2 (new variable)
interval âŒ unchanged


âœ… Solution 1: Add dependency
useEffect(() => {
  const id = setInterval(() => {
    console.log(count);
  }, 1000);
  return () => clearInterval(id);
}, [count]);

ğŸ“Œ Why it works:
Effect re-runs
New closure
Fresh count

What changes?
Every time count changes: Component re-renders
A new effect callback is created
Old effect is cleaned up
New closure is stored

Memory now:
Old closure âŒ destroyed
New closure:
  count â†’ latest value

So no stale state.

âœ… Solution 2: Functional update (BEST)
useEffect(() => {
  const id = setInterval(() => {
    setCount(c => {
      console.log(c);
      return c + 1;
    });
  }, 1000);
  return () => clearInterval(id);
}, []);


ğŸ“Œ Why this is powerful:
No stale closure, React gives latest state, Closure no longer depends on old count

â€œStale state bugs happen because effects close over state from the render they were created in, exactly like the var loop closure problem.â€
React docs say:

â€œIf the new state depends on the previous state, use the functional updater.â€

3ï¸âƒ£ Now the BIG question â€” why useRef fixes this ğŸ§ ğŸ”¥
Example with useRef
function Counter() {
  const [count, setCount] = useState(0);
  const countRef = useRef(count);

  countRef.current = count;

  useEffect(() => {
    setInterval(() => {
      console.log(countRef.current);
    }, 1000);
  }, []);

  return null;
}
  ğŸ”¹ What is useRef internally?

Think of it as:

const ref = {
  current: initialValue
};


React guarantees:
Same object across renders
Never replaced
Never re-created

ğŸ”¹ Render #1
count = 0
countRef = { current: 0 }


Effect closure captures:

countRef â†’ (reference to object)


âš ï¸ Notice:
Closure captures the object, not count

ğŸ”¹ Render #2 (after state update)
count = 1
countRef.current = 1


ğŸ” Same object, updated value

ğŸ”¹ Interval callback runs
console.log(countRef.current);


JS lookup:
countRef â†’ same object

.current â†’ latest value

ğŸ“Œ Output:
0
1
2
3

7ï¸âƒ£ When to use WHAT (important in interviews)
âœ… Use useRef when:

Intervals
Timeouts
Event listeners
WebSocket callbacks
Avoiding re-renders
Storing latest value

âŒ Do NOT use useRef when:
UI must update
Value affects rendering
