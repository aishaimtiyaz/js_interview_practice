// console.error(message);
      {/**
        What is Execution context
            Execution context is an environment where JS code evaluate and execute
            
            it create in two phases 
            1. creation phase where memory is allocated to variables, functions and this refrence 2. execution phase where code gets execute line by line and call functions 
            
            in creation phase hoisting happend where var variables hoist with undefined and let and const are hoisted but not initialized, and remain in the Temporal Dead Zone where variable is not accessible untill its initialization line reached and function gets fully hoisted

Execution context is the environment in which JavaScript code is evaluated and executed.
It is created in two phases:

1. Creation phase, where memory is allocated for variables, functions, and the this reference.
During this phase, hoisting happens ‚Äî var variables are initialized with undefined, function declarations are fully hoisted, while let and const are hoisted but stay in the Temporal Dead Zone.

2. Execution phase, where code is executed line by line and function calls create new execution contexts.
            
            example 
            console.log(a) --> undefined
            var a=10;
            console.log(b); --> refrence error
            let b=20;

        InDepth theory
        Execcution context is the environment where JS code is evaluated and executed. 
        It decides-
        -What Variables Exisit
        -What function exist
        -What this refres ti
        -How scope is resolved

        IT created in two phases 
        1. Global Execution Context (GEC)
         -Craeted when js file start running, -Only one per program
         Contains- Gloabal object (window in browser), this global object, all global variables and functions

        2. Functional Execution Context ()
          Created every every time when function gets called
          can be many
          Each function call -->  new execution context

         Each execution context is running in two phases
         1. Memory allocation phase - 
            Before running any code JS scans code and 
            CREATES:
            - variables Environment
            - Lexical Environments
            - Scope Chain
            - this Binding
          
            What happens to variables 
            var --> undefined
            let/const --> undefined(TDZ)
            functions declarations --> fully hoisted
          
         Example :
         console.log(a); //undefined
         var a = 10;
         console.log(b); //RefrencerError
         let b = 20;

         üîπ Function Hoisting
          foo() // works
          function foo(){
            console.log("hello");
          }

          function is stored entirely during creation phase.


          2Ô∏è‚É£ Execution Phase
          Now JS runs code line by line
          -Assigns actual values,
          -Executes functions
          -Creates new execution contexts for function calls

          üß† Call Stack & Execution Context
           JS uses call stack to manage execution contexts.
           example
           function a()
           {
             b();
           }
            function b()
            {
            console.log("b");
            } 
            a();

            CALL STACK FLOW 
            Global EC
             -> a() EC
               -> b() EC
            
            After execution:
            b() popped 
            a() popped
            back to global EC

            üîó Scope Chain (VERY FREQUENT QUESTION)
            Scope chain is a mechanism to resolve variables

            Each execution context has a refrence to 
             - its own lexical environment
             - parent lexical environment
             - Global environment

             ex-
             let x=10;
             function outer()
             {
               let y = 20;

               function inner()
               {
                 console.log(x,y);
               }
                 inner();
             }
                 outer();

            Resolution order: Inner -> outer -> global

            üß† this in Execution Context 

            Global EC
            this === window //browser

            Function EC
            function f() {
                console.log(this);
              }
            f(); //window (non-strict), undefined striuct mode


            METHOD EC
            obj.method(); this will be redirect to object here this = object

            Arrow Function
            No its own 'this'

            Inherit from its parent Execution Context

            ‚ö†Ô∏è Tricky Interview Edge Cases
            ‚ùì Why let is hoisted but inaccessible?

            console.log(a); // Refrence Error
            let a=20;

            because 'a' is hoisted but stays in TDZ untill initialization line is reached;

            ‚ùì Why function expressions are not hoisted?
            foo()//typeError

            var foo=>(){
            console.log('hello from foo');
            }
            
            foo is hoisted with undefined function body assigned later

           üî• FULL WALKTHROUGH (INTERVIEW GOLD )
           var a = 1;

            function outer() {
              var b = 2;

              function inner() {
                console.log(a + b);
              }

              inner();
            }

            outer();

            Step by Step
            1. Global EC
            a=undefined
            outer = functin full definition
            2. execution
            a=1;
            outer(); --> new EC -
            b=undefined
            inner = function

            SCOPE RESOLUTION 
            a from global
            b from outer

        üß† Interview One-Liners (MEMORIZE)

        EC is an environment that evaluate and execute the js, 
        JS creates Execution in two phases A. Creation and execution,
        Execution contexts are managed using the call stack,
        Scope chain resolves variables lexically

        üß™ MOST ASKED INTERVIEW QUESTIONS
        1. What is execution context?
        EC is an environment where JS code evaluate and execute.
        it creates in two phases 1. memory allocation phase that conatin global object this window in browser, function definition and  and execution phase
         and manged using the callstack,
         IT defines variables, functions, scope chain and value of this.
      2. Good. Can you tell me how execution context is related to the call stack?
Execution context defines the environment in which code runs, including variables, scope, and this,
the call stack is a data structure that keeps track of execution contexts- it pushes a new execution context whever a function is called and pops it once the function finises
üî• Tiny example (ONLY if interviewer asks)
function a() {
  b();
}
function b() {}
a();
Global EC
‚Üí a() EC
‚Üí b() EC
‚Üí pop b
‚Üí pop a

Can you explain how hoisting works internally using execution context?
Execution context defines the environment where JavaScript code is evaluated and executed.
It is created in two phases.

First is the creation phase, where memory is allocated for variables, function declarations, and the this reference.
During this phase, hoisting happens ‚Äî var variables are initialized with undefined, function declarations are fully hoisted, and let and const are hoisted but kept in the Temporal Dead Zone, so they cannot be accessed before initialization.

Second is the execution phase, where code runs line by line and variables are assigned their actual values.

‚è±Ô∏è ~30 seconds
Why does JavaScript need execution contexts? What problem does it solve?

  
    
    JS needs execution contexts to manage single threaded environment. Execution centexts provide a structured way to store variables , functions, scope chain, and the this value for each piece of code,
    They also allow js to track function calls using the call stack and support features like hoisting and lexical scoping.

    üß† If interviewer asks ‚Äúcan you simplify?‚Äù

You can add:
Without execution contexts, JavaScript wouldn‚Äôt know which variables belong to which function or how to execute nested calls correctly.

    üß† Simple mental model (for YOU)

Execution context = workspace for running code
Without it, JS wouldn‚Äôt know:
Which variables belong where
Which function is running
What this refers to
How to return after a function ends


How does execution context help JavaScript handle closures?
For every function call, JavaScript creates a new execution context that allocates memory for variables, functions, and the this value.
If an inner function accesses variables from its outer function, JavaScript preserves the outer function‚Äôs lexical environment.
This retained lexical environment is what forms a closure, allowing the inner function to access those variables even after the outer function‚Äôs execution context has finished.
‚è±Ô∏è ~20 seconds

If execution contexts are destroyed after function execution, how do closures still access variables?
      for every function call, JS creates a new execution context that allocaltes memory to variables, functions, and the this value.
    If an inner function accesses variables from its outer function JS preserves the outer function's lexical environment, This retained lexical environment is what forms closures,
    allowing the inner function to access those variables even after the outer functions's execution context has finished.
    ‚è±Ô∏è ~20 seconds
When a function finishes execution, its execution context is removed from the call stack.
However, if an inner function still references variables from that function, JavaScript preserves the lexical environment, not the execution context itself.
This preserved lexical environment is attached to the inner function, forming a closure, which allows the inner function to access those variables even after the outer function has finished executing.
‚è±Ô∏è ~20 seconds
        */}
