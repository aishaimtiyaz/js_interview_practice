// console.error(message);
      {/**
        What is Execution context
            Execution context is an environment where JS code evaluate and execute
            
            it create in two phases 
            1. creation phase where memory is allocated to variables, functions and this refrence 2. execution phase where code gets execute line by line and call functions 
            
            in creation phase hoisting happend where var variables hoist with undefined and let and const are hoisted but not initialized, and remain in the Temporal Dead Zone where variable is not accessible untill its initialization line reached and function gets fully hoisted

Execution context is the environment in which JavaScript code is evaluated and executed.
It is created in two phases:

1. Creation phase, where memory is allocated for variables, functions, and the this reference.
During this phase, hoisting happens â€” var variables are initialized with undefined, function declarations are fully hoisted, while let and const are hoisted but stay in the Temporal Dead Zone.

2. Execution phase, where code is executed line by line and function calls create new execution contexts.
            
            example 
            console.log(a) --> undefined
            var a=10;
            console.log(b); --> refrence error
            let b=20;

        InDepth theory
        Execcution context is the environment where JS code is evaluated and executed. 
        It decides-
        -What Variables Exisit
        -What function exist
        -What this refres ti
        -How scope is resolved

        IT created in two phases 
        1. Global Execution Context (GEC)
         -Craeted when js file start running, -Only one per program
         Contains- Gloabal object (window in browser), this global object, all global variables and functions

        2. Functional Execution Context ()
          Created every every time when function gets called
          can be many
          Each function call -->  new execution context

         Each execution context is running in two phases
         1. Memory allocation phase - 
            Before running any code JS scans code and 
            CREATES:
            - variables Environment
            - Lexical Environments
            - Scope Chain
            - this Binding
          
            What happens to variables 
            var --> undefined
            let/const --> undefined(TDZ)
            functions declarations --> fully hoisted
          
         Example :
         console.log(a); //undefined
         var a = 10;
         console.log(b); //RefrencerError
         let b = 20;

         ðŸ”¹ Function Hoisting
          foo() // works
          function foo(){
            console.log("hello");
          }

          function is stored entirely during creation phase.


          2ï¸âƒ£ Execution Phase
          Now JS runs code line by line
          -Assigns actual values,
          -Executes functions
          -Creates new execution contexts for function calls

          ðŸ§  Call Stack & Execution Context
           JS uses call stack to manage execution contexts.
           example
           function a()
           {
             b();
           }
            function b()
            {
            console.log("b");
            } 
            a();

            CALL STACK FLOW 
            Global EC
             -> a() EC
               -> b() EC
            
            After execution:
            b() popped 
            a() popped
            back to global EC

            ðŸ”— Scope Chain (VERY FREQUENT QUESTION)
            Scope chain is a mechanism to resolve variables

            Each execution context has a refrence to 
             - its own lexical environment
             - parent lexical environment
             - Global environment

             ex-
             let x=10;
             function outer()
             {
               let y = 20;

               function inner()
               {
                 console.log(x,y);
               }
                 inner();
             }
                 outer();

            Resolution order: Inner -> outer -> global

            ðŸ§  this in Execution Context 

            Global EC
            this === window //browser

            Function EC
            function f() {
                console.log(this);
              }
            f(); //window (non-strict), undefined striuct mode


            METHOD EC
            obj.method(); this will be redirect to object here this = object

            Arrow Function
            No its own 'this'

            Inherit from its parent Execution Context

            âš ï¸ Tricky Interview Edge Cases
            â“ Why let is hoisted but inaccessible?

            console.log(a); // Refrence Error
            let a=20;

            because 'a' is hoisted but stays in TDZ untill initialization line is reached;

            â“ Why function expressions are not hoisted?
            foo()//typeError

            var foo=>(){
            console.log('hello from foo');
            }
            
            foo is hoisted with undefined function body assigned later

           ðŸ”¥ FULL WALKTHROUGH (INTERVIEW GOLD )
           var a = 1;

            function outer() {
              var b = 2;

              function inner() {
                console.log(a + b);
              }

              inner();
            }

            outer();

            Step by Step
            1. Global EC
            a=undefined
            outer = functin full definition
            2. execution
            a=1;
            outer(); --> new EC -
            b=undefined
            inner = function

            SCOPE RESOLUTION 
            a from global
            b from outer

        ðŸ§  Interview One-Liners (MEMORIZE)

        EC is an environment that evaluate and execute the js, 
        JS creates Execution in two phases A. Creation and execution,
        Execution contexts are managed using the call stack,
        Scope chain resolves variables lexically

        ðŸ§ª MOST ASKED INTERVIEW QUESTIONS
        1. What is execution context?
        EC is an environment where JS code evaluate and execute.
        it creates in two phases 1. memory allocation phase that conatin global object this window in browser, function definition and  and execution phase
         and manged using the callstack,
         IT defines variables, functions, scope chain and value of this.
      2. Good. Can you tell me how execution context is related to the call stack?
Execution context defines the environment in which code runs, including variables, scope, and this,
the call stack is a data structure that keeps track of execution contexts- it pushes a new execution context whever a function is called and pops it once the function finises
ðŸ”¥ Tiny example (ONLY if interviewer asks)
function a() {
  b();
}
function b() {}
a();
Global EC
â†’ a() EC
â†’ b() EC
â†’ pop b
â†’ pop a
        */}
